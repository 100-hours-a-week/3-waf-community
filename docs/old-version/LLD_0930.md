# LLD.md - Low Level Design Document

## 문서 정보

| 항목 | 내용 |
|------|------|
| 프로젝트명 | KTB Community Platform |
| 작성일 | 2025-09-30 |
| 버전 | 1.0 |
| 문서 유형 | Low Level Design Document |
| 대상 독자 | 개발자 |

---

## 1. 기술 스택

### 1.1 백엔드 프레임워크
- **Spring Boot**: 3.5.6
- **Java**: 24
- **빌드 도구**: Gradle 8.x
- **패키지 구조**: `com.ktb.community`

### 1.2 데이터베이스
- **RDBMS**: MySQL 8.0+
- **스키마**: `community`
- **ORM**: JPA (Hibernate)
- **커넥션 풀**: HikariCP

### 1.3 주요 라이브러리
- **Spring Web**: RESTful API 구현
- **Spring Security**: 인증/인가
- **Spring Data JPA**: 데이터베이스 접근
- **Lombok**: 보일러플레이트 코드 감소
- **JWT**: 토큰 기반 인증
- **BCrypt**: 비밀번호 암호화
- **MySQL Connector**: 데이터베이스 드라이버

### 1.4 추후 도입 예정
- **AWS S3**: 이미지 스토리지
- **Redis**: 토큰 캐싱 (현재는 RDB 사용)

---

## 2. 시스템 아키텍처

### 2.1 전체 아키텍처

```
┌─────────────┐
│   Client    │
│ (Frontend)  │
└──────┬──────┘
       │ HTTPS
       │ REST API
┌──────▼──────┐
│  Controller │ ← Request/Response 처리
│   Layer     │
└──────┬──────┘
       │
┌──────▼──────┐
│  Service    │ ← 비즈니스 로직
│   Layer     │
└──────┬──────┘
       │
┌──────▼──────┐
│ Repository  │ ← 데이터 접근
│   Layer     │
└──────┬──────┘
       │ JPA/Hibernate
┌──────▼──────┐
│   MySQL     │
│  Database   │
└─────────────┘
```

### 2.2 3-Layer Architecture

#### Controller Layer
- **역할**: HTTP 요청 수신, 응답 반환
- **책임**:
  - DTO 검증 (Bean Validation)
  - 요청 데이터를 Service Layer로 전달
  - 응답 데이터 포매팅
- **명명 규칙**: `*Controller.java`
- **위치**: `com.ktb.community.controller`

#### Service Layer
- **역할**: 비즈니스 로직 처리
- **책임**:
  - 트랜잭션 관리 (`@Transactional`)
  - 비즈니스 규칙 검증
  - Repository 호출 및 조합
  - 엔티티 ↔ DTO 변환
- **명명 규칙**: `*Service.java`, `*ServiceImpl.java`
- **위치**: `com.ktb.community.service`

#### Repository Layer
- **역할**: 데이터베이스 접근
- **책임**:
  - CRUD 작업
  - 커스텀 쿼리 정의
  - JPA 메서드 활용
- **명명 규칙**: `*Repository.java`
- **위치**: `com.ktb.community.repository`

---

## 3. 패키지 구조

```
src/
├── main/
│   ├── java/
│   │   └── com/
│   │       └── ktb/
│   │           └── community/
│   │               ├── CommunityApplication.java
│   │               │
│   │               ├── config/              # 설정 클래스
│   │               │   ├── SecurityConfig.java
│   │               │   ├── JwtConfig.java
│   │               │   └── WebConfig.java
│   │               │
│   │               ├── controller/          # REST 컨트롤러
│   │               │   ├── AuthController.java
│   │               │   ├── UserController.java
│   │               │   ├── PostController.java
│   │               │   ├── CommentController.java
│   │               │   └── LikeController.java
│   │               │
│   │               ├── service/             # 비즈니스 로직
│   │               │   ├── AuthService.java
│   │               │   ├── UserService.java
│   │               │   ├── PostService.java
│   │               │   ├── CommentService.java
│   │               │   ├── LikeService.java
│   │               │   └── ImageService.java
│   │               │
│   │               ├── repository/          # 데이터 접근
│   │               │   ├── UserRepository.java
│   │               │   ├── PostRepository.java
│   │               │   ├── CommentRepository.java
│   │               │   ├── PostLikeRepository.java
│   │               │   ├── ImageRepository.java
│   │               │   ├── UserTokenRepository.java
│   │               │   └── PostStatsRepository.java
│   │               │
│   │               ├── entity/              # JPA 엔티티
│   │               │   ├── User.java
│   │               │   ├── Post.java
│   │               │   ├── Comment.java
│   │               │   ├── PostLike.java
│   │               │   ├── Image.java
│   │               │   ├── UserToken.java
│   │               │   ├── PostStats.java
│   │               │   └── PostImage.java
│   │               │
│   │               ├── dto/                 # 데이터 전송 객체
│   │               │   ├── request/
│   │               │   │   ├── LoginRequest.java
│   │               │   │   ├── SignupRequest.java
│   │               │   │   ├── PostCreateRequest.java
│   │               │   │   └── CommentCreateRequest.java
│   │               │   └── response/
│   │               │       ├── ApiResponse.java
│   │               │       ├── UserResponse.java
│   │               │       ├── PostResponse.java
│   │               │       └── CommentResponse.java
│   │               │
│   │               ├── security/            # 보안 관련
│   │               │   ├── JwtTokenProvider.java
│   │               │   ├── JwtAuthenticationFilter.java
│   │               │   └── CustomUserDetailsService.java
│   │               │
│   │               ├── exception/           # 예외 처리
│   │               │   ├── GlobalExceptionHandler.java
│   │               │   ├── CustomException.java
│   │               │   ├── ResourceNotFoundException.java
│   │               │   ├── UnauthorizedException.java
│   │               │   └── DuplicateResourceException.java
│   │               │
│   │               ├── util/                # 유틸리티
│   │               │   ├── PasswordValidator.java
│   │               │   └── DateTimeUtil.java
│   │               │
│   │               └── enums/               # 열거형
│   │                   ├── UserStatus.java
│   │                   ├── PostStatus.java
│   │                   ├── CommentStatus.java
│   │                   └── UserRole.java
│   │
│   └── resources/
│       ├── application.yaml                # 메인 설정
│       ├── application-dev.yaml            # 개발 환경 (선택)
│       ├── application-prod.yaml           # 운영 환경 (선택)
│       └── schema.sql                      # DDL 스크립트 (선택)
│
└── test/
    └── java/
        └── com/
            └── ktb/
                └── community/
                    ├── service/            # 서비스 테스트
                    └── repository/         # 레포지토리 테스트
```

---

## 4. 데이터베이스 설계

### 4.1 ERD 개요

```
┌─────────┐       ┌──────────┐       ┌─────────┐
│  users  │──1:N──│  posts   │──1:N──│comments │
└─────────┘       └──────────┘       └─────────┘
     │                  │                   │
     │                  │                   │
  N:1│               1:1│                1:N│
     │                  │                   │
┌─────▼────┐      ┌────▼──────┐            │
│  images  │      │post_stats │            │
└──────────┘      └───────────┘            │
     │                                      │
     │                                      │
  M:N│◄──┐                                 │
     │   │                                  │
┌────▼───▼──┐                              │
│post_images│                              │
└───────────┘                              │
                                           │
┌──────────┐                               │
│post_likes│◄──────────────────────────────┘
└──────────┘       (M:N via post_likes)
```

### 4.2 테이블 상세 설계

상세 DDL은 `@docs/DDL.md` 참조. 주요 테이블:

#### users (사용자)
- **Primary Key**: `user_id`
- **Unique Keys**: `email`, `nickname`
- **Indexes**: `user_status`
- **관계**:
  - 1:N → posts
  - 1:N → comments
  - 1:N → post_likes
  - 1:1 → images (프로필)
  - 1:N → user_tokens

#### posts (게시글)
- **Primary Key**: `post_id`
- **Indexes**: `created_at`, `(user_id, created_at)`
- **관계**:
  - N:1 → users
  - 1:N → comments
  - 1:N → post_likes
  - 1:1 → post_stats
  - M:N → images (via post_images)

#### comments (댓글)
- **Primary Key**: `comment_id`
- **Indexes**: `(post_id, created_at, comment_id)`
- **관계**:
  - N:1 → posts
  - N:1 → users

#### post_likes (좋아요)
- **Primary Key**: `like_id`
- **Unique Key**: `(user_id, post_id)` - 중복 방지
- **Indexes**: `post_id`
- **관계**:
  - N:1 → users
  - N:1 → posts

#### images (이미지)
- **Primary Key**: `image_id`
- **용도**: 프로필 이미지, 게시글 이미지

#### user_tokens (인증 토큰)
- **Primary Key**: `user_token_id`
- **Unique Key**: `token`
- **Indexes**: `user_id`, `expires_at`
- **관계**: N:1 → users

#### post_stats (게시글 통계)
- **Primary Key**: `post_id` (1:1 관계)
- **필드**: `like_count`, `comment_count`, `view_count`
- **관계**: 1:1 → posts

#### post_images (게시글-이미지 브릿지)
- **Composite Primary Key**: `(post_id, image_id)`
- **Unique Key**: `(post_id, display_order)` - 순서 중복 방지
- **관계**: M:N 브릿지 (posts ↔ images)

---

## 5. API 설계

### 5.1 공통 응답 구조

```json
{
  "message": "작업_결과_메시지",
  "data": {
    // 응답 데이터 또는 null
  },
  "timestamp": "2025-10-01T14:30:00"
}
```

### 5.2 공통 에러 응답

```json
{
  "message": "error_code",
  "data": {
    "field": ["필드명"],
    "details": "상세 메시지"
  },
  "timestamp": "2025-10-01T14:30:00"
}
```

### 5.3 API 엔드포인트 분류

상세 API는 `@docs/API.md` 참조. 주요 엔드포인트:

#### 인증 (Auth)
- `POST /auth/login` - 로그인
- `POST /auth/logout` - 로그아웃
- `POST /auth/refresh_token` - 토큰 갱신

#### 사용자 (Users)
- `POST /users/signup` - 회원가입
- `GET /users/{userID}` - 사용자 조회
- `PATCH /users/{userID}` - 사용자 수정
- `PATCH /users/{userID}/password` - 비밀번호 변경
- `PUT /users/{userID}` - 회원 탈퇴

#### 게시글 (Posts)
- `GET /posts` - 목록 조회 (페이지네이션, 정렬)
- `GET /posts/{postId}` - 상세 조회
- `POST /posts` - 작성
- `PATCH /posts/{postId}` - 수정
- `DELETE /posts/{postId}` - 삭제

#### 댓글 (Comments)
- `GET /posts/{postId}/comments` - 목록 조회
- `POST /posts/{postId}/comments` - 작성
- `PATCH /comments/{commentID}` - 수정
- `DELETE /comments/{commentID}` - 삭제

#### 좋아요 (Likes)
- `POST /posts/{postId}/like` - 좋아요 추가
- `DELETE /posts/{postId}/like` - 좋아요 취소
- `GET /users/me/likes` - 내가 좋아요한 게시글

---

## 6. 인증 및 보안

### 6.1 JWT 토큰 구조

#### Access Token
- **만료 시간**: 30분
- **용도**: API 인증
- **저장 위치**: 클라이언트 (메모리 또는 sessionStorage)
- **Payload**:
```json
{
  "sub": "user_id",
  "email": "user@example.com",
  "role": "USER",
  "iat": 1234567890,
  "exp": 1234569690
}
```

#### Refresh Token
- **만료 시간**: 7일
- **용도**: Access Token 갱신
- **저장 위치**:
  - 클라이언트: httpOnly 쿠키 또는 보안 스토리지
  - 서버: user_tokens 테이블 (RDB)
- **Payload**:
```json
{
  "sub": "user_id",
  "type": "refresh",
  "iat": 1234567890,
  "exp": 1235172690
}
```

### 6.2 인증 흐름

#### 로그인 플로우
```
1. 클라이언트 → POST /auth/login (email, password)
2. 서버: 이메일/비밀번호 검증
3. 서버: BCrypt로 비밀번호 비교
4. 서버: Access Token + Refresh Token 생성
5. 서버: Refresh Token을 user_tokens 테이블에 저장
6. 서버 → 클라이언트: 두 토큰 반환
```

#### API 호출 플로우
```
1. 클라이언트 → API 요청 (Authorization: Bearer {access_token})
2. 서버: JwtAuthenticationFilter가 토큰 검증
3. 서버: 토큰에서 사용자 정보 추출
4. 서버: SecurityContext에 인증 정보 저장
5. 서버: Controller → Service → Repository 실행
6. 서버 → 클라이언트: 응답 반환
```

#### 토큰 갱신 플로우
```
1. 클라이언트: Access Token 만료 감지 (401 에러)
2. 클라이언트 → POST /auth/refresh_token (refresh_token)
3. 서버: Refresh Token을 user_tokens 테이블에서 검증
4. 서버: 만료 여부 확인
5. 서버: 새로운 Access Token 생성
6. 서버 → 클라이언트: 새 Access Token 반환
```

### 6.3 Spring Security 설정

#### SecurityConfig.java

```java
@Configuration
@EnableWebSecurity
public class SecurityConfig {

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .csrf(csrf -> csrf.disable())
            .sessionManagement(session ->
                session.sessionCreationPolicy(SessionCreationPolicy.STATELESS)
            )
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/auth/**").permitAll()
                .requestMatchers("/posts").permitAll()
                .anyRequest().authenticated()
            )
            .addFilterBefore(jwtAuthenticationFilter(),
                           UsernamePasswordAuthenticationFilter.class);
        return http.build();
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
}
```

#### JwtAuthenticationFilter

```java
@Component
public class JwtAuthenticationFilter extends OncePerRequestFilter {

    @Override
    protected void doFilterInternal(HttpServletRequest request,
                                   HttpServletResponse response,
                                   FilterChain filterChain) {
        String token = resolveToken(request);

        if (token != null && jwtTokenProvider.validateToken(token)) {
            Authentication auth = jwtTokenProvider.getAuthentication(token);
            SecurityContextHolder.getContext().setAuthentication(auth);
        }

        filterChain.doFilter(request, response);
    }

    private String resolveToken(HttpServletRequest request) {
        String bearerToken = request.getHeader("Authorization");
        if (bearerToken != null && bearerToken.startsWith("Bearer ")) {
            return bearerToken.substring(7);
        }
        return null;
    }
}
```

#### Controller에서 인증 정보 사용

```java
@RestController
public class PostController {

    @PostMapping("/posts")
    public ApiResponse<PostResponse> createPost(
        @RequestBody PostCreateRequest request,
        @AuthenticationPrincipal CustomUserDetails userDetails
    ) {
        Long userId = userDetails.getUserId();
        return ApiResponse.success(postService.createPost(request, userId));
    }
}
```

### 6.4 비밀번호 정책

#### 검증 규칙
- 길이: 8자 이상, 20자 이하
- 대문자: 최소 1개 (`[A-Z]`)
- 소문자: 최소 1개 (`[a-z]`)
- 특수문자: 최소 1개 (`[!@#$%^&*(),.?":{}|<>]`)

#### 구현
```java
public class PasswordValidator {
    private static final String REGEX =
        "^(?=.*[a-z])(?=.*[A-Z])(?=.*[!@#$%^&*(),.?\":{}|<>]).{8,20}$";

    public static boolean isValid(String password) {
        return password != null && password.matches(REGEX);
    }
}
```

### 6.5 Rate Limiting

#### 구현 방안
- **방식**: AOP 기반 또는 Interceptor
- **제한**: 분당 100회
- **키**: IP 주소 + 사용자 ID (인증 시)
- **저장소**:
  - 현재: 인메모리 (ConcurrentHashMap)
  - 추후: Redis
- **응답**: 429 Too Many Requests

#### 예시 코드
```java
@Aspect
@Component
public class RateLimitAspect {

    private final Map<String, RateLimiter> limiters = new ConcurrentHashMap<>();

    @Around("@annotation(RateLimit)")
    public Object rateLimit(ProceedingJoinPoint pjp) throws Throwable {
        String key = getClientKey();
        RateLimiter limiter = limiters.computeIfAbsent(key,
            k -> RateLimiter.create(100.0 / 60.0)); // 분당 100회

        if (!limiter.tryAcquire()) {
            throw new TooManyRequestsException();
        }

        return pjp.proceed();
    }
}
```

---

## 7. 주요 비즈니스 로직

### 7.1 게시글 작성

#### 처리 흐름
```
1. Controller: DTO 검증 (제목 27자, 내용 필수)
2. Service: 인증된 사용자 확인
3. Service: Post 엔티티 생성 (상태: ACTIVE)
4. Service: 이미지 URL이 있으면 Image 엔티티 생성 및 연결
5. Repository: Post 저장
6. Repository: PostStats 초기화 (모든 카운트 0)
7. Service: PostResponse DTO 변환
8. Controller: 201 Created 응답
```

#### 핵심 코드
```java
@Service
@Transactional
public class PostService {

    public PostResponse createPost(PostCreateRequest request, Long userId) {
        User user = userRepository.findById(userId)
            .orElseThrow(() -> new ResourceNotFoundException("User not found"));

        Post post = Post.builder()
            .title(request.getTitle())
            .content(request.getContent())
            .status(PostStatus.ACTIVE)
            .user(user)
            .build();

        Post savedPost = postRepository.save(post);

        // 통계 초기화
        PostStats stats = PostStats.builder()
            .post(savedPost)
            .likeCount(0)
            .commentCount(0)
            .viewCount(0)
            .build();
        postStatsRepository.save(stats);

        // 이미지 처리
        if (request.getImageUrl() != null) {
            imageService.attachImage(savedPost, request.getImageUrl());
        }

        return PostResponse.from(savedPost);
    }
}
```

### 7.2 좋아요 처리

#### 처리 흐름
```
1. Controller: 게시글 ID, 사용자 ID 확인
2. Service: 게시글 존재 여부 확인
3. Service: 중복 좋아요 확인 (user_id, post_id)
4. Service: PostLike 엔티티 생성 및 저장
5. Service: PostStats의 like_count 증가 (+1)
6. Controller: 200 OK 응답 (현재 좋아요 수 포함)
```

#### 동시성 처리

**원자적 UPDATE 방식 사용:**

```java
@Service
@Transactional
public class LikeService {

    public LikeResponse addLike(Long postId, Long userId) {
        // 1. 중복 확인
        if (postLikeRepository.existsByUserIdAndPostId(userId, postId)) {
            throw new DuplicateResourceException("Already liked");
        }

        // 2. 좋아요 추가
        PostLike like = PostLike.builder()
            .user(userRepository.getReferenceById(userId))
            .post(post)
            .build();
        postLikeRepository.save(like);

        // 3. 통계 업데이트 (원자적 UPDATE)
        postStatsRepository.incrementLikeCount(postId);

        return LikeResponse.builder()
            .likeCount(getUpdatedLikeCount(postId))
            .build();
    }
}
```

**Repository 구현:**

```java
public interface PostStatsRepository extends JpaRepository<PostStats, Long> {

    @Modifying(clearAutomatically = true)
    @Query("UPDATE PostStats ps SET ps.likeCount = ps.likeCount + 1, " +
           "ps.lastUpdated = CURRENT_TIMESTAMP WHERE ps.postId = :postId")
    int incrementLikeCount(@Param("postId") Long postId);

    @Modifying(clearAutomatically = true)
    @Query("UPDATE PostStats ps SET ps.likeCount = ps.likeCount - 1, " +
           "ps.lastUpdated = CURRENT_TIMESTAMP " +
           "WHERE ps.postId = :postId AND ps.likeCount > 0")
    int decrementLikeCount(@Param("postId") Long postId);

    @Modifying(clearAutomatically = true)
    @Query("UPDATE PostStats ps SET ps.commentCount = ps.commentCount + 1, " +
           "ps.lastUpdated = CURRENT_TIMESTAMP WHERE ps.postId = :postId")
    int incrementCommentCount(@Param("postId") Long postId);

    @Modifying(clearAutomatically = true)
    @Query("UPDATE PostStats ps SET ps.commentCount = ps.commentCount - 1, " +
           "ps.lastUpdated = CURRENT_TIMESTAMP " +
           "WHERE ps.postId = :postId AND ps.commentCount > 0")
    int decrementCommentCount(@Param("postId") Long postId);

    @Modifying(clearAutomatically = true)
    @Query("UPDATE PostStats ps SET ps.viewCount = ps.viewCount + 1, " +
           "ps.lastUpdated = CURRENT_TIMESTAMP WHERE ps.postId = :postId")
    int incrementViewCount(@Param("postId") Long postId);
}
```

**선택 이유:** DB 레벨 원자적 연산으로 높은 동시성 환경에서 성능과 일관성 보장. 상세 내용은 Section 12.3 참조.

### 7.3 페이지네이션

#### 7.3.1 Offset/Limit 방식 (기본, 웹 환경)

**구현 방식**:
```java
@Service
@Transactional(readOnly = true)
public class PostService {

    public PostListResponse getPosts(int offset, int limit, String sort) {
        Pageable pageable = PageRequest.of(
            offset / limit,  // page number
            limit,
            getSort(sort)
        );

        Page<Post> page = postRepository.findByStatus(
            PostStatus.ACTIVE,
            pageable
        );

        List<PostResponse> posts = page.getContent().stream()
            .map(PostResponse::from)
            .collect(Collectors.toList());

        return PostListResponse.builder()
            .posts(posts)
            .pagination(PaginationResponse.builder()
                .totalCount(page.getTotalElements())
                .build())
            .build();
    }

    private Sort getSort(String sort) {
        return switch (sort) {
            case "likes" -> Sort.by(Sort.Direction.DESC, "stats.likeCount");
            case "latest" -> Sort.by(Sort.Direction.DESC, "createdAt");
            default -> Sort.by(Sort.Direction.DESC, "createdAt");
        };
    }
}
```

**장점**:
- 구현 단순
- 페이지 번호로 직접 이동 가능 (1페이지, 2페이지...)
- Spring Data JPA의 Pageable 지원

**단점**:
- Offset이 클수록 성능 저하 (OFFSET 1000은 1000개를 건너뛰는 비용 발생)
- 실시간 데이터 삽입 시 중복/누락 가능

---

#### 7.3.2 Cursor 기반 페이지네이션 (모바일 최적화)

**구현 방식**:
```java
@Service
@Transactional(readOnly = true)
public class PostService {

    public CursorPostListResponse getPostsByCursor(Long cursor, int limit) {
        List<Post> posts;

        if (cursor == null) {
            // 첫 요청: 최신 게시글부터
            posts = postRepository.findTopNByStatusOrderByCreatedAtDesc(
                PostStatus.ACTIVE,
                PageRequest.of(0, limit)
            );
        } else {
            // 다음 요청: cursor(마지막 post_id) 이후 게시글
            posts = postRepository.findByStatusAndIdLessThanOrderByIdDesc(
                PostStatus.ACTIVE,
                cursor,
                PageRequest.of(0, limit)
            );
        }

        Long nextCursor = posts.isEmpty() ? null :
                         posts.get(posts.size() - 1).getId();
        boolean hasMore = posts.size() == limit;

        return CursorPostListResponse.builder()
            .posts(posts.stream().map(PostResponse::from).toList())
            .nextCursor(nextCursor)
            .hasMore(hasMore)
            .build();
    }
}

// Repository
@Repository
public interface PostRepository extends JpaRepository<Post, Long> {

    @Query("SELECT p FROM Post p " +
           "WHERE p.status = :status AND p.id < :cursor " +
           "ORDER BY p.id DESC")
    List<Post> findByStatusAndIdLessThanOrderByIdDesc(
        @Param("status") PostStatus status,
        @Param("cursor") Long cursor,
        Pageable pageable
    );
}

// Response DTO
@Getter
@Builder
public class CursorPostListResponse {
    private List<PostResponse> posts;
    private Long nextCursor;      // 다음 요청 시 사용할 커서
    private boolean hasMore;      // 더 조회할 데이터 존재 여부
}
```

**API 엔드포인트**:
```java
@RestController
@RequestMapping("/posts")
public class PostController {

    // 기본: Offset/Limit (웹)
    @GetMapping
    public ApiResponse<PostListResponse> getPosts(
        @RequestParam(defaultValue = "0") int offset,
        @RequestParam(defaultValue = "10") int limit,
        @RequestParam(defaultValue = "latest") String sort
    ) {
        return ApiResponse.success(postService.getPosts(offset, limit, sort));
    }

    // 모바일: Cursor 기반
    @GetMapping("/cursor")
    public ApiResponse<CursorPostListResponse> getPostsByCursor(
        @RequestParam(required = false) Long cursor,
        @RequestParam(defaultValue = "20") int limit
    ) {
        return ApiResponse.success(postService.getPostsByCursor(cursor, limit));
    }
}
```

**장점**:
- 무한 스크롤에 최적화
- Offset 없이 인덱스 활용 → 높은 성능
- 실시간 삽입에도 중복/누락 없음

**단점**:
- 특정 페이지로 직접 이동 불가
- 구현 복잡도 증가

---

#### 7.3.3 성능 비교

| 항목 | Offset/Limit | Cursor 기반 |
|------|-------------|-------------|
| 구현 난이도 | 쉬움 | 보통 |
| 페이지 이동 | 가능 | 불가 |
| 무한 스크롤 | 보통 | 최적 |
| 성능 (작은 Offset) | 좋음 | 매우 좋음 |
| 성능 (큰 Offset) | 나쁨 | 매우 좋음 |
| 실시간 안정성 | 나쁨 | 좋음 |

**권장 사항**:
- **웹 환경**: Offset/Limit (페이지 번호 네비게이션)
- **모바일 앱**: Cursor 기반 (무한 스크롤)
- **하이브리드**: 두 방식 모두 제공 (엔드포인트 분리)

---

## 8. 예외 처리

### 8.1 커스텀 예외 계층

```
RuntimeException
    └── CustomException (추상)
            ├── ResourceNotFoundException (404)
            ├── DuplicateResourceException (409)
            ├── UnauthorizedException (401)
            ├── ForbiddenException (403)
            ├── ValidationException (400)
            └── TooManyRequestsException (429)
```

### 8.2 GlobalExceptionHandler

```java
@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(ResourceNotFoundException.class)
    public ResponseEntity<ApiResponse<Void>> handleNotFound(
            ResourceNotFoundException ex) {
        return ResponseEntity
            .status(HttpStatus.NOT_FOUND)
            .body(ApiResponse.error(ex.getMessage()));
    }

    @ExceptionHandler(DuplicateResourceException.class)
    public ResponseEntity<ApiResponse<Map<String, Object>>> handleDuplicate(
            DuplicateResourceException ex) {
        Map<String, Object> data = Map.of("field", ex.getFields());
        return ResponseEntity
            .status(HttpStatus.CONFLICT)
            .body(ApiResponse.error("resource_already_exists", data));
    }

    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ApiResponse<Void>> handleValidation(
            MethodArgumentNotValidException ex) {
        return ResponseEntity
            .status(HttpStatus.BAD_REQUEST)
            .body(ApiResponse.error("input_data_validation_failed"));
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity<ApiResponse<Void>> handleGeneral(Exception ex) {
        log.error("Unexpected error", ex);
        return ResponseEntity
            .status(HttpStatus.INTERNAL_SERVER_ERROR)
            .body(ApiResponse.error("internal_server_error"));
    }
}
```

---

## 9. 데이터 변환 (Entity ↔ DTO)

### 9.1 Entity to DTO

```java
@Getter
@Builder
public class PostResponse {
    private Long postId;
    private String title;
    private String content;
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;
    private UserSummary author;
    private PostStatsResponse stats;

    public static PostResponse from(Post post) {
        return PostResponse.builder()
            .postId(post.getPostId())
            .title(post.getTitle())
            .content(post.getContent())
            .createdAt(post.getCreatedAt())
            .updatedAt(post.getUpdatedAt())
            .author(UserSummary.from(post.getUser()))
            .stats(PostStatsResponse.from(post.getStats()))
            .build();
    }
}
```

### 9.2 DTO to Entity

```java
@Getter
@NoArgsConstructor
@AllArgsConstructor
public class PostCreateRequest {

    @NotBlank(message = "제목은 필수입니다")
    @Size(max = 27, message = "제목은 27자를 초과할 수 없습니다")
    private String title;

    @NotBlank(message = "내용은 필수입니다")
    private String content;

    private String imageUrl;

    public Post toEntity(User user) {
        return Post.builder()
            .title(this.title)
            .content(this.content)
            .status(PostStatus.ACTIVE)
            .user(user)
            .build();
    }
}
```

---

## 10. 설정 파일

### 10.1 application.yaml

```yaml
spring:
  datasource:
    url: jdbc:mysql://localhost:3306/community?serverTimezone=UTC&useSSL=false
    username: root
    password: ${DB_PASSWORD}  # 환경 변수 사용 권장
    driver-class-name: com.mysql.cj.jdbc.Driver
    hikari:
      maximum-pool-size: 10
      minimum-idle: 5
      connection-timeout: 30000
      idle-timeout: 600000
      max-lifetime: 1800000

  jpa:
    hibernate:
      ddl-auto: validate  # 운영: validate, 개발: update
    properties:
      hibernate:
        format_sql: true
        show_sql: false
        dialect: org.hibernate.dialect.MySQL8Dialect
    open-in-view: false  # OSIV 비활성화

logging:
  level:
    com.ktb.community: DEBUG
    org.hibernate.SQL: DEBUG
    org.hibernate.type.descriptor.sql.BasicBinder: TRACE

jwt:
  secret: ${JWT_SECRET}  # 환경 변수 필수
  access-token-validity: 1800000   # 30분 (밀리초)
  refresh-token-validity: 604800000 # 7일 (밀리초)

rate-limit:
  requests-per-minute: 100
```

---

## 11. 테스트 전략

### 11.1 단위 테스트

#### Service Layer 테스트
```java
@ExtendWith(MockitoExtension.class)
class PostServiceTest {

    @Mock
    private PostRepository postRepository;

    @Mock
    private UserRepository userRepository;

    @Mock
    private PostStatsRepository postStatsRepository;

    @InjectMocks
    private PostService postService;

    @Test
    @DisplayName("게시글 작성 성공")
    void createPost_Success() {
        // Given
        Long userId = 1L;
        PostCreateRequest request = new PostCreateRequest(
            "테스트 제목", "테스트 내용", null
        );
        User user = User.builder().userId(userId).build();
        Post post = request.toEntity(user);

        when(userRepository.findById(userId)).thenReturn(Optional.of(user));
        when(postRepository.save(any(Post.class))).thenReturn(post);

        // When
        PostResponse response = postService.createPost(request, userId);

        // Then
        assertNotNull(response);
        assertEquals("테스트 제목", response.getTitle());
        verify(postRepository, times(1)).save(any(Post.class));
        verify(postStatsRepository, times(1)).save(any(PostStats.class));
    }
}
```

#### Repository Layer 테스트
```java
@DataJpaTest
@AutoConfigureTestDatabase(replace = AutoConfigureTestDatabase.Replace.NONE)
class PostRepositoryTest {

    @Autowired
    private PostRepository postRepository;

    @Autowired
    private UserRepository userRepository;

    @Test
    @DisplayName("게시글 상태별 조회")
    void findByStatus() {
        // Given
        User user = userRepository.save(createUser());
        Post post1 = postRepository.save(createPost(user, PostStatus.ACTIVE));
        Post post2 = postRepository.save(createPost(user, PostStatus.DELETED));

        Pageable pageable = PageRequest.of(0, 10);

        // When
        Page<Post> result = postRepository.findByStatus(
            PostStatus.ACTIVE, pageable
        );

        // Then
        assertEquals(1, result.getTotalElements());
        assertEquals(post1.getPostId(), result.getContent().get(0).getPostId());
    }
}
```

### 11.2 테스트 커버리지 목표
- **Service Layer**: 80% 이상
- **Repository Layer**: 60% 이상
- **전체 프로젝트**: 60% 이상

---

## 12. 성능 최적화

### 12.1 데이터베이스 최적화

#### N+1 문제 해결
```java
@Repository
public interface PostRepository extends JpaRepository<Post, Long> {

    @Query("SELECT p FROM Post p " +
           "JOIN FETCH p.user " +
           "LEFT JOIN FETCH p.stats " +
           "WHERE p.status = :status")
    Page<Post> findByStatusWithUserAndStats(
        @Param("status") PostStatus status,
        Pageable pageable
    );
}
```

#### 인덱스 활용
- DDL.md에 정의된 인덱스 활용
- 복합 인덱스 순서 주의 (선택도 높은 컬럼 우선)
- 쿼리 실행 계획(EXPLAIN) 분석

### 12.2 캐싱 전략 (추후)

#### Redis 도입 시
- **토큰 관리**: Refresh Token을 Redis에 저장
- **세션 관리**: 사용자 세션 정보 캐싱
- **데이터 캐싱**: 자주 조회되는 게시글 목록
- **TTL 설정**: 데이터 특성에 맞는 만료 시간

### 12.3 동시성 제어

#### PostStats 원자적 UPDATE

**문제:** 좋아요/댓글/조회수의 동시 업데이트 시 Race Condition 발생 가능

**해결:** DB 레벨 원자적 UPDATE 사용

```sql
-- 읽기-계산-쓰기를 단일 트랜잭션으로 처리
UPDATE post_stats
SET like_count = like_count + 1,
    last_updated = NOW()
WHERE post_id = ?;
```

**구현 예시:**
```java
@Modifying(clearAutomatically = true)
@Query("UPDATE PostStats ps SET ps.likeCount = ps.likeCount + 1, " +
       "ps.lastUpdated = CURRENT_TIMESTAMP WHERE ps.postId = :postId")
int incrementLikeCount(@Param("postId") Long postId);
```

**적용 대상:**
- `viewCount`: 조회수 증가 (가장 빈번)
- `likeCount`: 좋아요 증감
- `commentCount`: 댓글 수 증감

**대안 검토:**
- ❌ 낙관적 락 (@Version): 재시도 폭증으로 부적합
- ❌ 비관적 락 (FOR UPDATE): 단순 증감에 과도
- ✅ 원자적 UPDATE: 성능과 일관성 최적

**Phase 3+ 최적화:** 조회수는 버퍼링 고려 (1초마다 배치 업데이트)

---

## 13. 배포 및 운영

### 13.1 환경 변수

운영 환경에서 필수 환경 변수:
```bash
DB_PASSWORD=<MySQL 비밀번호>
JWT_SECRET=<256bit 이상의 시크릿 키>
```

### 13.2 배치 작업 (추후)

#### 만료 토큰 정리
```sql
DELETE FROM user_tokens
WHERE expires_at < NOW();
```

- 스케줄링: 매일 새벽 3시 실행
- Spring @Scheduled 또는 Cron Job 활용

### 13.3 로그 관리

#### 로그 레벨
- **운영**: INFO
- **개발**: DEBUG
- **에러**: ERROR (항상)

#### 주요 로그 포인트
- API 요청/응답 (요청 시간, 사용자 ID, 엔드포인트)
- 인증 실패 (로그인 시도, 토큰 검증 실패)
- 비즈니스 로직 에러 (스택 트레이스 포함)

---

## 14. 추후 개선 사항

### 14.1 단기 (1-2개월)
- [ ] S3 실제 연동 (이미지 업로드)
- [ ] Redis 도입 (토큰 관리)
- [ ] Admin API 구현

### 14.2 중기 (3-6개월)
- [ ] 검색 기능 (Elasticsearch 고려)
- [ ] 알림 시스템 (WebSocket)
- [ ] 통계 대시보드

### 14.3 장기 (6개월+)
- [ ] MSA 전환 고려
- [ ] Event-Driven Architecture
- [ ] CQRS 패턴 적용

---

## 변경 이력

| 날짜 | 버전 | 변경 내용 | 작성자 |
|------|------|-----------|--------|
| 2025-09-30 | 1.0 | 초기 LLD 작성 | Claude Code |